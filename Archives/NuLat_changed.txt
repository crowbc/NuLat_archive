/*******************************************/
/*            C++ header files             */
/*******************************************/
// might not be needed if things like G4cout and G4endl are used. Most C++ methods exist in G4 libraries
#include <time.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <errno.h>
#include <iostream>
#include <fstream>
/*******************************************/
/*      Geant4 defined header files        */
/*******************************************/
#include "Randomize.hh"
#include "G4UImanager.hh"
#include "G4VisExecutive.hh"
#include "G4UIExecutive.hh"
#include "G4ios.hh"
// Set RunManager according to Multithread status
#ifdef G4MULTITHREADED
#include "G4MTRunManager.hh"
#else
#include "G4RunManager.hh"
#endif
//Physics Lists
#include "G4HadronicProcessStore.hh"
#include "QGSP_BERT_HP.hh"
#include "G4StepLimiterPhysics.hh"
#include "G4OpticalPhysics.hh"
#include "G4DecayPhysics.hh"
#include "G4RadioactiveDecayPhysics.hh"
/*******************************************/
/*      User/NuLat simulation developer    */
/*          defined header files           */
/*******************************************/
#include "NuLatDetectorConstruction.hh"
#include "NuLatActionInitialization.hh"

using namespace std;
/*******************************************/
/*    int main( int argc, char** argv )    */
/*    This is where the simulation begins. */
/*******************************************/
int main(int argc, char** argv)
{
	G4UIExecutive *ui = 0;
	if ( argc == 1 ) {
		ui = new G4UIExecutive(argc, argv);}
	// Simulation parameters now set in messenger of NuLatDetectorConstruction.cc
	// Number of voxels in x y and z - set these as defaults in constructor
	G4int nXVoxels = 5;
	G4int nYVoxels = 5;
	G4int nZVoxels = 5;
  	// voxel dimmensions x y and z - set these as defaults in constructor
	//G4double xVoxelSize = 2.495*2.54*cm;
	//G4double yVoxelSize = 2.495*2.54*cm;
	//G4double zVoxelSize = 2.495*2.54*cm;
	// voxel spacing x y and z - set these as defaults in constructor
	//G4double xVoxelSpace = 0.005*2.54*cm;
	//G4double yVoxelSpace = 0.005*2.54*cm;
	//G4double zVoxelSpace = 0.005*2.54*cm;
	/**********************************************/
	/* The random number generator is initialized */
	/**********************************************/
	G4int myseed = 0;//time( NULL );
	G4Random::setTheEngine(new CLHEP::RanluxEngine);
	G4Random::setTheSeed(myseed);
	G4String cmd = "/control/execute ";
	G4String mac = "Macros/init_vis.mac";
	/****************************************************/
	/*                                                  */
	/* Construct the default run manager                */
	/* single or multi threaded                         */
	/*                                                  */
	/****************************************************/
#ifdef G4MULTITHREADED
	G4cout << "Multithread is currently disabled." << G4endl;
	G4RunManager *runManager = new G4RunManager;  
	// Multithread is currently disabled.
	//G4MTRunManager *runManager = new G4MTRunManager;
	//runManager->SetNumberOfThreads(G4Threading::G4GetNumberOfCores());
#else
	G4RunManager *runManager = new G4RunManager;
#endif
	/****************************************************/
	/* Create the detector and point run manager to it  */
	/* To access the code responsible for this geometry */ 
	/* view the following files:                        */
	/* src/NuLatDetectorConstruction.cc                 */
	/* include/NuLatDetectorConstruction.hh             */
	/****************************************************/
	NuLatDetectorConstruction *NuLatDetector = new NuLatDetectorConstruction();
	runManager->SetUserInitialization(NuLatDetector);
	/****************************************************/
	/* Define physics to use in the detector and point  */
	/* run manager to it                                */
	/* currently using predefined physics lists         */
	/****************************************************/
	// create physics class and constructor for this. Initialize in runManager
	G4VModularPhysicsList *physicsList = new QGSP_BERT_HP(0);
	physicsList->SetVerboseLevel(0);
	G4HadronicProcessStore::Instance()->SetVerbose(0);
	physicsList->RegisterPhysics(new G4OpticalPhysics(0));
	physicsList->RegisterPhysics(new G4DecayPhysics(0));
	physicsList->RegisterPhysics(new G4RadioactiveDecayPhysics(0));
	runManager->SetUserInitialization(physicsList);
	/****************************************************/
	/* User action initialization                       */
	/****************************************************/
	runManager->SetUserInitialization(new NuLatActionInitialization(nXVoxels, nYVoxels, nZVoxels));// fix this next
	/*****************************************************/
	/* If Visualization support exists Create visManager */
	/*****************************************************/
	G4VisManager *visManager = new G4VisExecutive;
	visManager->Initialize();
	/*****************************************************/
	/* Get the pointer to the User Interface manager     */
	/*****************************************************/
	G4UImanager *UImanager = G4UImanager::GetUIpointer();
	if (argc>1)  
	{
		// batch mode
		/***********************************************************/
		/* Run in batch mode by having the user interface manager  */
		/* executing the macro file passed via the command line    */
		/***********************************************************/
		mac=(G4String)argv[1];
		UImanager->ApplyCommand(cmd+mac);
	}
	else
	{
		// interactive mode : define UI session
		//runManager->Initialize();// vis.mac?
		UImanager->ApplyCommand(cmd+mac);
		ui->SessionStart();
		delete ui;
	}
	delete visManager;
	delete runManager;
	return 0;
}
